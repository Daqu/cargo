SDS原型(二) 日报
================

SDS原型（二）
=============

SDS VS 对象存储
---------------

前面提到笔者的一个观点：凡是实现了restful接口的对象存储系统都可以看成是SDS的存储系统。那么，为什么要在对象存储上进行SDS的实践呢？如何实践？好处是什么？

为什么
~~~~~~

在笔者看来，SDS代表一种架构，其目的是为了实现存储层次的控制和数据分离。前面说实现restful接口的对象存储可以看成是SDS系统，如果再详细一点可以说是提供restful接口的对象存储系统已经包含SDS的思想，但是从功能、架构上说还不是SDS架构。从功能上说，并没有给用户提供清晰的控制功能。从架构上看，目前对象存储的各模块基本都是基于功能的不同而划分的。

举个例子，openstack
swift的功能主要是关于文件的读取比如增删查改，关于文件控制的功能目前它只是提供了一个中间件机制来对请求进行过滤。如果把一个系统的各功能代码量所占总代码用百分比来描述这个功能所受重视程度的话，那么swift中控制部分的百分比是低于数据部分的。但是SDS提倡控制和数据分离，为什么要分离，因为要做更多的控制，为什么要做更多的控制，因为要提供更好的使用体验和更高的开发效率。也就是说，目前的对象存储或多或少地提供了控制层的功能，但是这距离SDS对控制的要求还有一定的距离。

因此，笔者说要在对象存储上实践SDS的目的是增强对象存储的控制层的功能。

目前已经有的SDS方案
~~~~~~~~~~~~~~~~~~~

何谓实践?在it领域，就是将一套方案应用到某个业务场景中。那么，目前有哪些已经实现的SDS方案呢？(特指基于管理的SDS)

1.IOflow

早期的SDS原型，环境是windows。但是没有后续工作

2.openstack swift

    swift通过提供基于HTTP协议的API给外界调用来完成对象存储的功能，我们从swift的各个部署说明里面可以看到，proxy
    server和storage
    node的配置文件里面都有一个\ ``[pipeline:main]``\ ，这个是swift各个服务的请求链，由多个中间件组成的一个中间件集合。pipeline有点像J2EE里面filter，每个http请求需要经过各个服务的pipeline。

一个pipeline实例如下

.. code:: python

    pipeline = catch_errors healthcheck proxy-logging bulk ratelimit crossdomain slo cache tempurl tempauth staticweb account-quotas container-quotas proxy-logging proxy-server

一个pipeline就是一群中间件的序列，可以看到。swift通过中间件可以来完成一些校验工作，比如catch\_errors检查请求是否合法、完成记录工作比如proxy-logging。

3.crystalSDS

crystal基于swift，它把swift当做数据层，它自己作为控制层。每一个向swift发出的文件请求都会被加入到swift
pipeline的crystal的中间件拦截。等到控制层的crystal执行完之后再将请求发到下一个中间件。

通过这种机制，crystal可以实现一些原本文件系统无法实现的功能，比如将文件先压缩再存储，先解压再读取。

SDS的好处
~~~~~~~~~

SDS的好处是什么呢，提高了使用体验。举个例子，比如扫地，一个完整的步骤拿起扫把->逐个房间清扫->倒垃圾->放好工具。在这里，有一个叫做crystal的扫地机器人，如果使用crystal来扫地，那么整个过程就变成拿出crystal->按下扫地开关->关掉crystal->倒垃圾->放好crystal。

对于用户来说，这极大地提升了扫地体验。因为原来需要一个个房间地走动，但是得益于crystal，现在这个步骤省去了。

然而，就这个扫地的过程来说。整个过程其实变得复杂了，因为crystal在扫地的时候需要动态的判断障碍，动态改变路线。这个过程需要极大的计算量。

看起来似乎这个举动没有好处啊，但是在这个场景中，用户体验是第一位的，毕竟是用户购买的产品。随着技术的发展，性能的提升越来越廉价。在性能与用户体验各占一边的天平上，随着市场的作用，天平是越来越倾向于用户体验这一边的。

SDS也是如此，它提高了项目的规模，但却能带来更清晰易懂的架构和更好的用户体验。

目前SDS方案的不足
-----------------

1.ioflow

基于文件系统，实现控制层的开销过大

2.swift

控制功能不够丰富，不能支持更加复杂的操作，比如修改文件的存储格式、将文件进行拆分与合并。

3.crystal

与swift紧密耦合，每一个crystal实例是运行在沙盒环境中的，这是优点但也有局限性。比如使用crystal对多个文件进行合并，由于crystal实例之间的隔离性导致实例之间通信难度和开销较大。

4.seaweedfs

缺少控制层

聚焦的问题
----------

笔者发现，在对象存储中。一个请求-响应的过程可以分为

::

    start
    # 网络
    客户端
    ->http 文件请求
    ->服务端 接收
    ->路由转发
    # 存储
    ->函数调用
    ->读写
    ->返回结果
    # 网络
    ->服务端 发出响应
    ->客户端收到响应
    end

在现有的SDS方案中，控制层没有覆盖到上面整个流程。crystal、swift的控制只能针对网络请求，但是当网络请求转化为文件io请求的时候无法进行控制。seaweedfs则相反，它将每一个文件都抽象为needle，对其能够进行合并操作。但是却没有请求拦截、重定向等功能。

因此，笔者希望实现一个对象存储的控制层，它能够就对象存储的文件请求的整个生命流程进行控制。
